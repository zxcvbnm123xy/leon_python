"""
第三章 运算符
运算符：具有特殊计算规则的符号
操作数：运算时，参数运算的数据
N元 运算符：具有N个操作数
由运算符和操作数结合起来的计算式，称为表达式
"""
"""
算术运算符
比较运算符
逻辑运算符
位运算符
成员运算符
身份运算符

注意：有些资料比较运算符、成员运算符、身份运算符都看成是比较运算符
"""
# 一、算术运算符
# + - * /
a=18
b=6
print(a+b,a-b,a*b,a/b)

# // 取整 python中是向下取整，向负无穷大方向取整。
print(-10//3)
print(10//3)


# % 取模:求余数
# 被除数=除数*商+余数
# 余数=被除数-除数*商
# 商：向下取整
print(10%3)
# 10-3*3=1
print(10%-3)
# 10-(-3)*(-4)=-2

# math函数下fmod 取余运算：结果存储的形式是浮点数。
# 商是正数，规则跟取模一样，商向下取整
# 商是负数，商向上取整
import math
print(math.fmod(10,3))
# 10-3*3=1
print(math.fmod(10,-3))
# 10-(-3)*(-3)=1
print(math.fmod(-10,3))
# -10-3*(-3)=-1

# 取模运算，结果符号同除数
# 取余运算，结果符号同被除数

# 练习：-9 -2 取余运算和取模运算
# 模
print(-9%-2)
# -9-(-2)*4=-1
# 余
print(math.fmod(-9,-2))
# -9-(-2)*4=-1


# **幂运算
print(5**2)


# 二、比较运算符
# 返回值是布尔类型，比较的是两个值之间的关系
# ==  !=  >  <   >=  <=   (python2中不等于<>)
a=5
b=11
print(a==b) # 表示比较的是值的内容相等
print(a!=b)
print(a>b)
print(a<b)

# python中可以支持链式比较(同样支持短路)
# 1<x<5   x>1 并且 x<5
# 10 < x > 5


# 三、身份运算符
# is  is not
# 比较两个对象是否是同一个（内存地址）
a=1
b=1
print(a is b)
print(a == b)

#  对于列表、类、字典 注意区分is 和==
# 数值、布尔类型、字符串、字节 is和==返回结果是一致。

# 四、逻辑运算符（布尔运算符）
# 返回值可能是布尔类型
# 也可能是计算值
# and：第一个表达式为真，第二表达式也为真的时候，返回真，否则返回假
# or：两个表达式同时为假，返回的假，否则返回真
# not：对布尔类型取反
#(1) and或者or左右两侧返回的都是布尔类型，最终的返回值是布尔类型
print(True and True)
print(False and True)
print(False and False)
print(False and False)
print(False or False)
print(False or True)
print(not False)

a=1
b=2
c=2
print(a>b and b<c)
print(False and False)

#（2）and或者or左右两侧是其他类型，返回的是其中一个值
# 因为任何一个类型都能够转换成布尔类型
print(3 and "abc")
print(3 and "")
print(0 and "abc")

print(3 or "abc")
print(0 or "abc")

# 结论：
"""
and 或者or左右两侧都是其他类型（表达式）
对于and，第一个表达式为True，则返回第二个表达式
         第一个表达式为False，则返回第一个表达式
对于or， 第一个表达式为True，则返回第一个表达式
        第一个表达式为False，则返回第二个表达式
"""

# 短路现象：
"""
and:当第一个表达式为假，则后面的表达式不执行（出现短路）
or: 当第一个表达式为真，则后面的表达式不执行（出现短路） 
"""
False and print("不执行")
True or print("不执行")

print(True) or print("ddddd")

a=print("不执行")
print(a)
print(bool(None))



# 五、位运算符
# 对于二进制的各个位进行的运算符
# 原码、反码、补码
# 正数：原码，反码，补码
# 负数：
# 原码：正数的原码，符号位变1
# 反码：原码的符号位不变，其余取反
# 补码: 反码+1
# 计算机中存储的所有值都是以补码的形式存储。
# 补码变回原码：反码+1  或者-1反码
# 练习：
# -2+4=2
#1110
#0100
#0010

#-4+2=-2
# 1100
# 0010
# 1110 补码
#       1001+1=1010======= -2
"""
计算的步骤：
（1）先估计一下计算得到的结果需要使用几位机
    >-7并<8     使用4位机  #计算熟练 0<s<15(不考虑最高是符号位)
    结果<-7      使用8位机
    结果<-32767  使用16位机
（2）将操作数转换成补码
（3）进行运算
（4）结果如果最高位1 则为负数，需要将补码转换回原码，再得到十进制结果
     结果如果最高位0 则为整数。直接返回十进制结果。

"""
print(2**15-1)

# 7+8
# 0111    00000111
# 1000    00001000
# 1111    00001111
# 7-6=1

# 都是使用补码进行运算
a=-2
b= 5
# &  按位与 :两个都为1，结果为1，否则为0
print(-2&5)
# 1010---1101----1110
# 0101-----------0101
#                0100----4
print(0b1011010&0b111101)
# 0b1011010
# 0b0111101

# |  按位或：两个都为0，结果为0，否则为1
# 1010---1101----1110
# 0101-----------0101
#                1111----1001-----  -1
print(-2|5)

# ^  按位异或：两个不一样为1，一样为0
# 1010---1101----1110
# 0101-----------0101
#                1011----1101-----  -5
print(-2^5)

# ~  按位取反：包括符号位都取反
# 1010---1101----1110
#                0001-----1
print(~-2)


# << 将所有的位左移几位
# 右侧以0填充，左侧原有的位数不变(64位机)（如果真正四位机、八位机，左移，左侧位是溢出）
# -15<<2
print(bin(15))
# -15的原码   10001111
#            11110001
#          1111000100
#            11000100---10111100-------  - 2**5+2**4+2**3+2**2  =-60
print(2**5+2**4+2**3+2**2)
print(-15<<2)
# 向左位移一位，相当于*2


# >> 将所有的位右移几位
# 左侧需要使用符号位填充，正数填0，负数填1，右侧的数字直接溢出
# -15的原码   10001111
#            11110001
print(-15>>1)
#            11111000
#            10001000-------  -8
print(-16>>1)
# 右位移相当于//2  向下取整