一、长连接和短连接
	长连接：基于TCP/IP，即建立连接后，一段时间内保持连接状态，通过同一个连接频繁发送数据
		优缺点：节省建立连接的时间损耗，但是占用了服务器的连接数和部分资源
	短连接：基于TCP/IP，即建立连接后，通讯数据，完成后，立马断开连接
		优缺点：频繁的建立连接，额外的时间损耗，但是节省服务器的连接数和资源
		
二、http协议的无连接
	1、客户端连接服务器，通过TCP3次握手建立连接
	2、客户端发送request
	3、服务器接收到客户端的request后，解析，返回对应的response
	4、TCP的4次挥手，结束连接
	
	在http1.1中
	增加了一个
	connnection:  Keep-Alive
	保持一个有限的长连接，一定时间内，不断开
	
	WebSocket：
	其实是一个基于TCP的新的协议，但是相当于http的扩展
	
	使用websocket之前，要想实现实时刷新数据，
	必须采取轮询的方式：客户端间隔一定时间（譬如1秒）发送一个请求，询问是否有新的资讯
	
	使用websocket：
	通过http协议，建立连接，连接建立后，保持长连接状态，客户端和服务器都可以随时发送数据给对方
	
		
三、http协议的无状态
	服务器端不保存客户端的任何信息，每次都认为客户端是一个新的请求，所有信息都需要客户端重新提交
	
	session：
		服务器用于记录客户端数据的对象
	
	cookie：
		客户端用于记录服务器的数据
		
	客户端请求服务器的时候，每次都会携带cookie中的数据，以此让服务器识别客户端，

四、斜杠和反斜杠
    /  :  斜杠
    \  :  反斜杠

五、域名
    顶级域名、一级域名、二级域名、三级域名。。。。。
    baidu.com  :  顶级域名、一级域名
    www.baidu.com  :  二级域名，特殊的二级域名，一般用于和顶级域名一个含义
    baike.baidu.com ： 二级域名
    test.baike.baidu.com  :  三级域名

六、request的headers
    User-Agent: 告诉服务器，客户端的操作系统和浏览器，在反爬过程中，有可能使用到
    Accept:  告诉服务器，客户端接收的内容的格式， 一般可以使用： */*  通配
    Accept-Encoding: 告诉服务器，客户端接收的压缩方式，常见的：gzip, deflate, br
        注意，如果发现接收到的数据不管怎么处理都是乱码，那么记得去掉这个配置
    Referer： 上一个请求url，  爬虫中经常用到
    Accept-Language： 客户端支持的语言

七、request
    GET 方法没有请求体！ 但是可以提交参数，参数在 url后的 ?  号后面

    POST 方法的请求, 主要的请求体方式：
    form表单： email=15776574737&icode= 这样的格式
    json：  {'email': '15776574737'} 这样的格式
    file：  传送文件


    注意：POST请求也可以携带 url 参数！！！！

八、response中的 headers 中 Set-Cookie：
    这个值可以有任意多个，是服务器用于通知客户端应该记录一些什么信息
    格式如下：
    Set-Cookie: _de=BE8314F84CBEC59152DF21116448AF9E; domain=baike.baidu.com; path=/; expires=Thu, 17-Oct-2019 02:36:53 GMT
    _de： 该cookie的key， = 后面是 cookie的value  ，  这一项是我们最关心的！
    domain： 该cookie值所属的域
        域名的归属，是具有继承性质，域名本身和它的下级域名(test.baike.baidu.com)可以访问该值，
        其他域名无权限访问（兄弟域名：img.baidu.com, 父域名也得不到：baidu.com）
    path： 该cookie所属的 url 中 的 path
        path和domain一样，具有继承性质， path本身和子path都可以访问
        兄弟path和父path都不能访问
    expires: 失效时间，还有另外一个写法 Max-age
    size： cookie的大小
    http： 使用http协议的时候， 是否使用这个cookie
    secure：  使用https时，是否使用这个cookie

九、response中的 响应正文（响应体）
    最常见的：
    html：  html格式的文本内容
    json： {'key':'value'}  这样的格式

    下面的相对应用场景就会少很多：
    js：  js脚本
    图片

十、避免乱码问题
    究极解决方案：所有能看到编码的地方，能设置的地方，都设置为 UTF-8

十一、编码详解
    常见的编码：
    UTF-8
    GBK(ANTI、cp936)
    ASCII
    GB2312
    ISO-8859-1

    编码集是什么？
    用于图形界面显示对应的编码集，其实就是图形
    字节对应的图案是什么

    ASCII:  最早起实现图形界面时， 计算机中的 字节对应的 字符集
        只使用了 0x00 -- 0x7F
        1个字节
    ISO-8859-1: 西欧字符集,还有一些ISO-8859-2、ISO-8859-3、ISO-8859-4.。。。。。
        计算机发展到欧洲后，发现ASCII码没有包含他们特有的字符，
        兼容ASCII码
        进行扩展， 0x80 -  0xFF
        1个字节
    GB2312： 中文简体编码集
        计算机发展到中国后，创造的字符集
        2个字节，兼容 ASCII
        所有的2个字节的内容（中文、全角符号等），高位字节和地位字节都必须大于 0x7F
    GBK:  中文编码集，包括繁体
        2个字节，兼容 GB2312
        只需要高位字节大于0x7F，低位字节不限制
    GB18030:
        1字节、2字节和4字节三种方式对字符编码
        兼容GBK
    BIG5： 台湾的繁体中文字符集
        2个字节

    unicode:  每种语言中的每个字符设定了统一并且唯一的二进制编码
        17个平面
        其中有一个BMP基础平面，是 2个字节 ， 一般的中文也是2个字节
        其他16个平面都是 4 字节
        不兼容ASCII
        类似 你好啊 = \u4f60\u597d\u554a

    UTF-8： UTF-8 、 UTF-16、UTF-32
        可变字节， 1个字节、2个字节、3个字节、4个字节， 中文是3个字节
        兼容ASCII

        1、小于 0x80 ，对应ASCII
        2、多字节
            读一个字节，大于0x7f之后，展开为 2进制
            字节的高位有几个连续的1，那么就代表需要取几个字节
            110* ****   代表是2个字节表示一个字符
            1110 ****   代表是3个字节表示一个字符
            1111 0***   代表是4个字节表示一个字符

            后续根着的字节，前面2位必须是 10 这个 2位无实际意义

            汉字 ： 中
            对应utf-8的字节： b'\xe4\xb8\xad'
            展开：  e4  b8  ad
              e    4      b   8      a    d
            1110  0100  1011  1000  1010  1101
            去掉第一个字节的表示位数的 1110  和后续的字节的高2位 10
            0100  11  1000   10  1101
            每8位进行拼接：
            0100 1110  0010 1101
            4e 2d
            对应的 unicode编码就是： \u4e2d

十二、空格和空是有差异
    s = ''  # 这个是空字符串，  if 判断的话，是 false
    s1 = ' '  # 这个是 空格 字符串， 有显示的，只不过显示的是一段 空白， if判断是true