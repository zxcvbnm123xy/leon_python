# 1.# 手工计算 - 27 的二进制原码、反码和补码， 使用程序输出 - 27的二进制码
# 27的二进制
print(bin(27))  #11011
# 计算机中最高位 4   8   16   32   64
#27  原码00011011
#-27 原码10011011
#-27 反码11100100
#-27 补码11100101
print(bin(-27))


# 2.# 手工计算位运算结果， & ， | ， ^ ，并用程序验证：
# 7 和 - 3 、7 和3 、-7 和3、-7 和 - 3
#     原码    反码    补码
# 7   0111
# -7  1111    1000    1001
# 3   0011
#-3   1011    1100    1101

print(-3&-7)
1001
1101
# 1001----补码---1111原码-----    -7
print("0&-7=",0&-7)

print(-3|-7)
1001
1101
# 1101 ---补码---1011原码-----     -3

# 3.# 模仿计算机计算 - 7 + 3的过程
#     原码    反码    补码
# 7   0111
# -7  1111    1000    1001
# 3   0011
#-3   1011    1100    1101
# 1001
# 0011
# 1100   ---补码-----1011+1=1100-----十进制  -4
print(-7+3)
print(bin(-7+3))

# 4.# 证明and与or短路现象的存在。不用课堂的方式。
# 方式一：
# and  第一个表达式为假
0 and print("ddddd")
# or  第一个表达式为真
1 or print("dddd")


# 方式二：
# and  第一个表达式为假
0 and input()
# or  第一个表达式为真
1 or input()


# 方式三：
# 1/0
# print("其他的代码段")
# and  第一个表达式为假
0 and 1/0
# or  第一个表达式为真
1 or 1/0

# 编译的时候就已经报错了 ，语法错误不能证明短路现象
# 1 or print(



# 5.# 思考一个问题， & 通过和哪个数运算，可以达到运算之后得到自身
print(bin(-27))
# 10011011  八位机
# 11111111
# 1 55个0  11011
#64个1==》-1
print(-27&-1)

# 6.# 怎么在计算机中显示出来 - 27 的补码？
# 显示的是-27的补码，但是实际不是-27补码
print(bin(-27&0b11111111))

